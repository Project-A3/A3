import {
  __spreadProps,
  __spreadValues,
  presets
} from "./chunk-NAOYLS2B.mjs";

// src/index.ts
import { promises as fs } from "fs";
import { createUnplugin } from "unplugin";
import { throttle } from "@antfu/utils";

// src/core/options.ts
import { resolve } from "path";
import { toArray } from "@antfu/utils";
import { createFilter } from "@rollup/pluginutils";
import { isPackageExists } from "local-pkg";
function resolveOptions(options = {}) {
  const imports = flattenImportsMap(options.imports, options.presetOverriding);
  const {
    dts = isPackageExists("typescript")
  } = options;
  const resolved = __spreadProps(__spreadValues({
    sourceMap: false,
    resolvedImports: {},
    presetOverriding: false,
    ignore: []
  }, options), {
    dts: dts === false ? false : dts === true ? resolve("auto-imports.d.ts") : resolve(dts),
    imports,
    resolvers: toArray(options.resolvers),
    idFilter: createFilter(options.include || [/\.[jt]sx?$/, /\.vue$/, /\.vue\?vue/, /\.svelte$/], options.exclude || [/[\\/]node_modules[\\/]/, /[\\/]\.git[\\/]/])
  });
  return resolved;
}
function flattenImportsMap(map, overriding = false) {
  const flat = {};
  toArray(map).forEach((definition) => {
    if (typeof definition === "string") {
      if (!presets[definition])
        throw new Error(`[auto-import] preset ${definition} not found`);
      const preset = presets[definition];
      definition = typeof preset === "function" ? preset() : preset;
    }
    for (const mod of Object.keys(definition)) {
      for (const id of definition[mod]) {
        const meta = {
          module: mod
        };
        if (Array.isArray(id)) {
          meta.name = id[1];
          meta.from = id[0];
        } else {
          meta.name = id;
        }
        if (flat[meta.name] && !overriding)
          throw new Error(`[auto-import] identifier ${meta.name} already defined with ${flat[meta.name].module}`);
        flat[meta.name] = meta;
      }
    }
  });
  return flat;
}

// src/core/transform.ts
import MagicString from "magic-string";
var excludeRE = [
  /\bimport\s*([\s\S]+?)\s*from\b/g,
  /\bfunction\s*([\w_$]+?)\s*\(/g,
  /\b(?:const|let|var)\s+?(\[[\s\S]*?\]|\{[\s\S]*?\}|[\s\S]+?)\s*?[=;\n]/g
];
var matchRE = /(?<![\w_$]\.)([\w_$]+?)[^\w_${]/g;
var importAsRE = /^.*\sas\s+/;
var seperatorRE = /[,[\]{}\n]/g;
var multilineCommentsRE = /\/\*\s(.|[\r\n])*?\*\//gm;
var singlelineCommentsRE = /\/\/\s.*/g;
var templateLiteralRE = /\$\{(.*)\}/g;
var quotesRE = [
  /(["'])((?:\\\1|(?!\1)|.|\r)*?)\1/gm,
  /([`])((?:\\\1|(?!\1)|.|\n|\r)*?)\1/gm
];
function stripeCommentsAndStrings(code) {
  return code.replace(multilineCommentsRE, "").replace(singlelineCommentsRE, "").replace(templateLiteralRE, "` + $1 + `").replace(quotesRE[0], '""').replace(quotesRE[1], "``");
}
function transform(code, id, {
  imports,
  sourceMap,
  resolvers,
  resolvedImports = {},
  ignore = []
}) {
  const striped = stripeCommentsAndStrings(code);
  const identifiers = new Set(Array.from(striped.matchAll(matchRE)).map((i) => i[1]));
  ignore.forEach((i) => {
    if (typeof i === "string") {
      identifiers.delete(i);
    } else {
      identifiers.forEach((id2) => {
        if (id2.match(i))
          identifiers.delete(id2);
      });
    }
  });
  if (!identifiers.size)
    return null;
  for (const regex of excludeRE) {
    Array.from(striped.matchAll(regex)).flatMap((i) => {
      var _a, _b;
      return [
        ...((_a = i[1]) == null ? void 0 : _a.split(seperatorRE)) || [],
        ...((_b = i[2]) == null ? void 0 : _b.split(seperatorRE)) || []
      ];
    }).map((i) => i.replace(importAsRE, "").trim()).forEach((i) => identifiers.delete(i));
  }
  if (!identifiers.size)
    return null;
  const modules = {};
  const addToModules = (info) => {
    if (!modules[info.module])
      modules[info.module] = [info];
    else
      modules[info.module].push(info);
  };
  Array.from(identifiers).forEach((name) => {
    let info = getOwn(resolvedImports, name) || getOwn(imports, name);
    if (!info && (resolvers == null ? void 0 : resolvers.length)) {
      const resolved = firstNonNullResult(resolvers, name);
      if (resolved) {
        if (typeof resolved === "string") {
          info = {
            module: resolved,
            name,
            from: "default"
          };
        } else {
          info = resolved;
        }
        resolvedImports[name] = info;
      }
    }
    if (!info || !info.module)
      return;
    addToModules({
      module: info.module,
      name: info.name,
      from: info.from
    });
    if (info.sideEffects) {
      const infos = [info.sideEffects].flat(1).map((info2) => {
        if (typeof info2 === "string")
          return { module: info2 };
        return info2;
      });
      infos.forEach((info2) => addToModules(info2));
    }
  });
  if (!Object.keys(modules).length)
    return;
  const importStatements = Object.entries(modules).map(([moduleName, names]) => {
    const imports2 = [];
    const namedImports = [];
    names.forEach(({ name, from }) => {
      if (name) {
        if (from === "*")
          imports2.push(`* as ${name}`);
        else if (from === "default")
          imports2.push(name);
        else
          namedImports.push(from ? `${from} as ${name}` : name);
      }
    });
    if (namedImports.length)
      imports2.push(`{ ${namedImports.join(", ")} }`);
    return `import ${imports2.length > 0 ? `${imports2.join(", ")} from ` : ""}'${moduleName}';`;
  }).join("");
  const s = new MagicString(code);
  s.prependLeft(0, importStatements);
  return {
    code: s.toString(),
    map: sourceMap ? s.generateMap({ source: id, includeContent: true }) : null
  };
}
function firstNonNullResult(array, name) {
  for (let i = 0; i < array.length; i++) {
    const res = array[i](name);
    if (res)
      return res;
  }
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function getOwn(object, key) {
  return hasOwnProperty.call(object, key) ? object[key] : void 0;
}

// src/core/dts.ts
function generateDeclaration(imports, resolvedImports = {}) {
  const body = [
    ...Object.entries(imports),
    ...Object.entries(resolvedImports)
  ].sort((a, b) => a[0].localeCompare(b[0])).map(([name, info]) => `  const ${name}: typeof import('${info.module}')['${info.from || name}']`).join("\n");
  return `// Generated by 'unplugin-auto-import'
// We suggest you to commit this file into source control
declare global {
${body}
}
export {}
`;
}

// src/index.ts
var src_default = createUnplugin((options) => {
  const resolved = resolveOptions(options);
  if (!Object.keys(resolved.imports).length && !resolved.resolvers.length)
    console.warn("[auto-import] plugin installed but no imports has defined, see https://github.com/antfu/unplugin-auto-import#configurations for configurations");
  const generateDeclaration2 = throttle(500, false, () => {
    if (!resolved.dts)
      return;
    fs.writeFile(resolved.dts, generateDeclaration(resolved.imports, resolved.resolvedImports), "utf-8");
  });
  generateDeclaration2();
  return {
    name: "unplugin-auto-import",
    enforce: "post",
    transformInclude(id) {
      return resolved.idFilter(id);
    },
    transform(code, id) {
      const res = transform(code, id, resolved);
      if (res && resolved.resolvers.length)
        generateDeclaration2();
      return res;
    }
  };
});

export {
  src_default
};
